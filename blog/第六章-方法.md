
---
title: 第六章-方法
date: 2019-02-19 14:21:37
categories:
- 提升
- 语言
tags: 
- golang
---

在声明函数的时候，在其名字前放上一个变量，就是方法的声明。这个附加的变量，会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
形如：
~~~
func (p Point) Distance (q Point) float64{
  return 0.0
}
~~~
代码中附加的参数p 叫作方法的接收器（receiver）早期的面向对象语言留下的描述语言将调用一个方法称为“向一个对象发送消息”。
所以这里就是向p这个对象发送 Distance。
在Go中，并没有其他语言的this或者self指代接收器；可以任意指定接收器的名字，类似示例代码中的p,调用方法的方式就是p.method（参数）的方式。
**注意，一个类中不能声明一样名称的字段和方法，因为这里会有歧义，对于GO来说它不知道调用哪个p.X 当你为p结构体定义了一个字段X就不能定一个相同名称的方法，否则报错**
go可以为任意类型定义方法，这点和其他的语言不太一样，，我们可以为简单的数值，字符串，slice，map定义方法，用于附加行为，使其更加方便，但是不能为一个接口或者一个指针定义方法，因为他们本身没有承载。
* * * *
####基于指针对象的方法
调用函数的时候，会对每一个参数进行拷贝，当参数过大的时候我们会选择使用指针，一样，当接收器过大的时候，我们也会选择使用指针来当方法的接收器。
~~~
func (p *Point)ScaleBy(factor float64){
  p.x*=factor
  ……
}
~~~
这个方法的名字是（*Point）.ScaleBy 这个括号是必须的，没有括号的话可以理解为*（Point.ScaleBy）基于指针对象的方法为了避免歧义是不允许 出现如果一类型名本身是一个指针的话，是不允许其出现在接收器中的。
~~~
type P *int
func (P) f(){
  /****/
}
~~~
这种方法声明是错误的,
*指针对象方法的调用：*
~~~
r:=&Point{1,2}
r.ScaleBy(2)
//或者
p:=Point{1,2}
pptr = &p
pptr.ScaleBy(2)
//或者
p:=Point{1,2}
(&p).ScaleBy(2)
~~~
总结：1无论你的方法的接收器是指针类型还是非指针类型，都可以通过指针类型或者非指针类型进行调用，编译器会帮助你做类型转换；
2在声明一个方法的时候，考虑使用指针类型接收器，还是非指针类型接收器需要考虑两点，**1**这个对象本身是不是特别大。因为非指针类型接收器再每次调用的时候都会拷贝一份接收器。**2**如果使用指针类型接收器，那么一定要注意一点就是，这种指针类型的指向始终是一块内存地址。
* * * *
nil是对象的零值表现形式，所以nil可以作为方法的接收器，用于判断空对象的情况，使用它的时候多存在于对某一类型的空值判断：
~~~
type Intlist  struct {
    Value int
    Tail  *IntList
}
func (list *Intlist) Sum() int{
  if list ==nil{
    return 0
  }
return list.Value+ list.Tail.Sum()
}
~~~
* * * *
go中的**"继承"**
这里写继承是指对应面向对象编程中，子类继承父类的形式，但是go中实现类似功能，但是原理是不一样的，这里go通过内嵌结构体来扩展类型：
~~~
import "image/color"
type Point struct {X,Y float64}
type ColoredPoint struct {
  Point
  Color color.RGBA
}
~~~
这里ColoredPoint 结构体就拥有了X,Y属性值，可以调用Point的X和Y，也可以调用，接收器为Point的方法，但是，这个**继承**并不是继承父类的意思，而是拥有一个分部的意思，ColoredPoint拥有Point这个部分，可以用它的方法，但是当有方法或者函数需要Point类型的参数的时候，并不可以直接使用ColoredPoint进行传参会报错，可以用ColoredPoint的Point部分进行传参。

方法值与方法表达式。 可以将一个方法赋值给一个变量，然后用类似调用函数的方式来使用这个方法：
~~~
p:=Point{1,2}
q:=Point{4,6}
func (q Point ) Distance(p Point) int{
  /***
为了方便理解将这个内置函数，仿照着写在这里。
* */
}
distanceFromP :=p.Distance
distanceFromP(q)//直接调用，而不是p.Distance(q)
~~~
* * * *
####Bit数组
在数据流分析领域非常常见的非负整数数组。其实它就是一个uint64类型的数组，不过因为计算机每八位一个字节，用bit可以很快的完成这点。






