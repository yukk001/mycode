
---
title: 第二章-程序结构
date: 2019-02-19 14:21:37
categories:
- [提升,语言]
- [提升,读书]
tags: 
- golang
---

基础知识结构
-----
* 命名 
* 声明
* 变量
* 赋值
* 类型
* 包和文件 
* 作用域
* * *
####命名
命名规则：一个名字必须以一个字母（unicode字母）或者下划线开头，后面可以跟任意数量的字母数字或者下划线。区分大小写。
go的25个关键字如下：
>break ; default; func ; interface ;select ;  case ;  defer ;  go  ; map ; struct ; chan; else ; goto ; package ;switch ; const ; fallthrough ; if ; range ; type ; continue ; for ; import ; return ; var ;
>
----
内建常量与内建函数如下
>常量：true ;  false  ;    iota  ; nil 
内建类型  ：    int   ;   int8   ; int16  int32    int 64 
             >         uint uint8  uint16  uint32  uint64  uintptr
             >         float32 float64 complex128  complex64
             >         bool type rune string  error
内建函数 ： make  len  cap  new  append   copy  close  delete 
                     complex real imag 
                    panic recover 
-----
golang  推荐驼峰式命名  同时默认规定 首字母大写的变量可以包外引用，首字母小些的变量 只能包内调用  （汉字变量目前为止首字母被认定为小写）
* * * *
####声明
声明语句定义了程序的各种实体对象以及部分或全部的属性。 golang 中只要有四种类型的声明语句 ： var const type func 分别对应 变量声明，常量声明，类型声明和函数声明。    
* * * *
声明一个量之后如果直接调用默认会返回改变量类型的零值。
####变量
* new函数，使用new（T）函数会创建一个类型为T的零值变量，并返回其物理地址；
* * *
* 变量的生命周期 
变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期一致。而相对的，在局部变量的生命周期是动态的： **从每次创建一个新变量的生命语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收**

* go的垃圾回收机制基础理解（实现思路）：
**从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或者应用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径。那么说明该变量是不可达的，也就是说它是否存在不会影响程序的后续运算结果。（该结果的选择不是由VAR或者new声明方式决定的。）**

* * * 
####赋值
普通的赋值 略
* * *
元组赋值
允许更新多个变量，这里之所以把元组赋值单独提出来，是因为golang有基础错误与成功与否的判断机制，就是单函数拥有多个返回值用于判断是否有错误与是否成功例子： 
```
f,err = os.Open("fileName")
v.ok = x.(T)
_,ok = m[key]//判断map中是否有这个值
//等等
```
* * *
####类型
golang允许自定义类型 所以两个变量判断相当的条件为值相同同时类型也相同；类型和类型之间存在转换，转换后的值比较更具操作性；
####包和函数
主要注意事项为 引入顺序是有编译器的顺序决定的，并不是由导入顺序决定的。
####作用域

一个程序可以包含多个同名的声明只要作用域不相同是可以正常编译运行的，不过因为这样会导致代码理解出现误差。
作用域的主要理解如果按照书上所说是好大一段，个人理解为，大部分作用域的范围为其生命的代码块，除了逃逸变量与包可导出变量，这些变量的作用域可以扩大到他们的引入代码块。另外操作块的声明变量只生存于子操作块，这里主要是指 if for  switch块。












